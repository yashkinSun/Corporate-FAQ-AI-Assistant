# Техническая документация: Телеграм-бот поддержки клиентов с ИИ функционалом

**Дата создания:** 7 августа 2025  

## Аннотация

Данная техническая документация представляет детальный анализ архитектуры и функционала телеграм-бота поддержки клиентов с интегрированным искусственным интеллектом. Система реализует современный подход к автоматизации клиентской поддержки, объединяя технологии RAG (Retrieval-Augmented Generation), многоуровневую систему эскалации к операторам-людям, веб-интерфейс для управления базой знаний и комплексную систему обратной связи.

Архитектура построена на базе Python с использованием Flask для веб-интерфейса, python-telegram-bot для интеграции с Telegram API, LangChain для работы с языковыми моделями, ChromaDB для векторного поиска и PostgreSQL для хранения структурированных данных. Система поддерживает контейнеризацию через Docker и обеспечивает горизонтальное масштабирование компонентов.

## Содержание

1. [Обзор архитектуры](#обзор-архитектуры)
2. [Компоненты системы](#компоненты-системы)
3. [Модуль телеграм-бота](#модуль-телеграм-бота)
4. [Система RAG и управления знаниями](#система-rag-и-управления-знаниями)
5. [Веб-интерфейс и API](#веб-интерфейс-и-api)
6. [Система хранения данных](#система-хранения-данных)
7. [Утилиты и вспомогательные модули](#утилиты-и-вспомогательные-модули)
8. [Конфигурация и настройки](#конфигурация-и-настройки)
9. [Безопасность и ограничения](#безопасность-и-ограничения)
10. [API Reference](#api-reference)




## Обзор архитектуры

Система представляет собой многокомпонентное приложение, построенное по принципам микросервисной архитектуры с четким разделением ответственности между модулями. Основная архитектура следует паттерну MVC (Model-View-Controller) с дополнительными слоями для обработки естественного языка и управления знаниями.

### Архитектурные принципы

Система спроектирована с учетом следующих архитектурных принципов:

**Модульность и разделение ответственности.** Каждый компонент системы отвечает за конкретную область функциональности. Модуль `bot/` обрабатывает взаимодействие с Telegram API, `retrieval/` управляет поиском и извлечением информации из базы знаний, `webapp/` предоставляет веб-интерфейс для администрирования, а `storage/` абстрагирует работу с различными системами хранения данных.

**Слабая связанность компонентов.** Взаимодействие между модулями осуществляется через четко определенные интерфейсы. Например, система RAG взаимодействует с базой данных через абстрактный слой в `storage/`, что позволяет легко заменять реализации хранилища без изменения бизнес-логики.

**Конфигурируемость и расширяемость.** Все ключевые параметры системы вынесены в конфигурационный файл `config.py`, который поддерживает переменные окружения. Это обеспечивает гибкость развертывания в различных средах без изменения кода.

**Отказоустойчивость и обработка ошибок.** Система включает механизмы retry для операций с базой данных, graceful degradation при недоступности внешних сервисов и комплексное логирование для диагностики проблем.

### Технологический стек

Система построена на следующем технологическом стеке:

**Backend Framework:** Python 3.10+ с Flask 2.3.3 для веб-компонентов и python-telegram-bot 20.7 для интеграции с Telegram API.

**AI и NLP:** LangChain 0.1.14+ для работы с языковыми моделями, OpenAI API 1.14.3 для генерации ответов, tiktoken 0.6.0 для токенизации текста.

**Векторная база данных:** ChromaDB 0.4.24 для хранения эмбеддингов документов и семантического поиска, DuckDB 0.10.0 как встроенная аналитическая база данных.

**Реляционная база данных:** PostgreSQL с поддержкой SQLAlchemy 2.0.23 для ORM, psycopg2-binary 2.9.9 для подключения к PostgreSQL.

**Кэширование и очереди:** Redis 5.0.1 для rate limiting, кэширования и управления сессиями.

**Парсинг документов:** PyPDF2 3.0.1 для PDF файлов, python-docx 1.1.0 для документов Word, openpyxl 3.1.2 для Excel файлов.

**Безопасность:** bcrypt 4.1.2 для хеширования паролей, PyJWT 2.8.0 и Flask-JWT-Extended 4.6.0 для аутентификации и авторизации.

**Контейнеризация:** Docker с docker-compose для оркестрации сервисов, включая PostgreSQL, Redis и основное приложение.

### Архитектурные слои

Система организована в несколько логических слоев:

**Слой представления (Presentation Layer)** включает Telegram Bot API интерфейс для конечных пользователей и веб-интерфейс для операторов и администраторов. Этот слой обрабатывает входящие запросы, валидирует данные и форматирует ответы.

**Слой бизнес-логики (Business Logic Layer)** содержит основную логику обработки запросов пользователей, включая анализ намерений, поиск в базе знаний, генерацию ответов с помощью ИИ и управление эскалацией к операторам.

**Слой доступа к данным (Data Access Layer)** абстрагирует работу с различными системами хранения, включая реляционную базу данных для структурированных данных, векторную базу для семантического поиска и файловую систему для документов.

**Слой интеграции (Integration Layer)** обеспечивает взаимодействие с внешними сервисами, такими как OpenAI API, Telegram API и потенциальными CRM системами.

### Потоки данных

Основные потоки данных в системе можно разделить на несколько категорий:

**Обработка пользовательских запросов.** Когда пользователь отправляет сообщение в Telegram, оно проходит через слой валидации и санитизации в `utils/input_sanitization.py`, затем анализируется на предмет языка и намерений. Если запрос требует поиска информации, система обращается к RAG pipeline в `retrieval/`, который извлекает релевантные документы из ChromaDB, применяет переранжирование с помощью LLM и формирует контекст для генерации ответа.

**Управление сессиями и эскалация.** Система отслеживает сессии пользователей в PostgreSQL, включая историю сообщений, уровни уверенности ответов и временные метки эскалации. При необходимости эскалации к оператору создается запрос в `bot/operator.py`, который уведомляет доступных операторов через Telegram и управляет передачей диалога.

**Обновление базы знаний.** Администраторы могут загружать документы через веб-интерфейс в `webapp/ops/routes.py`. Документы парсятся с помощью `retrieval/doc_parser.py`, разбиваются на чанки, векторизуются и сохраняются в ChromaDB для последующего поиска.

**Аналитика и мониторинг.** Система собирает метрики использования, включая количество запросов, уровни уверенности ответов, частоту эскалации и оценки пользователей. Эти данные доступны через веб-интерфейс в `webapp/stats/routes.py`.


## Компоненты системы

Система состоит из нескольких ключевых компонентов, каждый из которых выполняет специфические функции в общей архитектуре.

### Структура проекта

```
BotVopro_Lightened_Beta/
├── bot/                    # Модули телеграм-бота
│   ├── __init__.py
│   ├── clarifications.py   # Система уточнений
│   ├── dialogues.py        # Управление диалогами
│   ├── feedback.py         # Система обратной связи
│   ├── handlers.py         # Основные обработчики сообщений
│   ├── operator.py         # Система эскалации к операторам
│   └── telegram_bot.py     # Основной модуль бота
├── controllers/            # Контроллеры бизнес-логики
│   ├── __init__.py
│   ├── broadcast.py        # Система рассылок
│   ├── query_controller.py # Обработка пользовательских запросов
│   └── user_access.py      # Управление доступом пользователей
├── data/                   # Директория данных
│   ├── chroma_db/         # База векторных данных ChromaDB
│   ├── documents/         # Загруженные документы
│   └── followup_map.json  # Карта follow-up вопросов
├── logs/                   # Логи системы
├── migrations/             # Миграции базы данных
│   ├── __init__.py
│   └── followup_extension.py
├── retrieval/              # Система RAG
│   ├── __init__.py
│   ├── doc_parser.py      # Парсинг документов
│   ├── indexer.py         # Индексация документов
│   ├── question.py        # Обработка вопросов
│   ├── reranker.py        # LLM переранжирование
│   └── retriever.py       # Поиск релевантных документов
├── services/               # Внешние сервисы
│   ├── __init__.py
│   └── crm_client.py      # Интеграция с CRM
├── storage/                # Слой хранения данных
│   ├── __init__.py
│   ├── database.py        # SQLite интерфейс (устаревший)
│   ├── database_sqlalchemy.py # SQLAlchemy ORM с исправлениями
│   ├── database_unified.py # Унифицированный модуль БД
│   └── request_history.py # История запросов
├── utils/                  # Утилиты
│   ├── __init__.py
│   ├── db_monitor.py      # Мониторинг базы данных
│   ├── followup_manager.py # Управление follow-up вопросами
│   ├── greeting_detector.py # Детектор приветствий
│   ├── input_sanitization.py # Санитизация ввода
│   ├── language_detection.py # Определение языка
│   ├── message_utils.py    # Утилиты для сообщений
│   ├── openai_client.py    # Клиент OpenAI API
│   ├── rate_limit.py       # Rate limiting
│   ├── response_validation.py # Валидация ответов
│   └── thinking_indicator.py # Индикатор "думает"
├── webapp/                 # Веб-интерфейс
│   ├── auth/              # Аутентификация
│   │   ├── jwt_auth.py    # JWT аутентификация
│   │   └── routes.py      # Маршруты аутентификации
│   ├── ops/               # Операционные маршруты
│   │   ├── routes.py      # Основные операции
│   │   └── routes_upload_fix.py # Исправления загрузки
│   ├── routes/            # Дополнительные маршруты
│   │   ├── history.py     # История сообщений
│   │   └── profile.py     # Профили пользователей
│   ├── stats/             # Статистика
│   │   └── routes.py      # Маршруты статистики
│   ├── static/            # Статические файлы
│   ├── templates/         # HTML шаблоны
│   ├── app.py             # Основное Flask приложение
│   └── health.py          # Health check endpoints
├── config.py               # Конфигурация системы
├── main.py                 # Точка входа для Telegram бота
├── run.py                  # Универсальная точка входа
├── webapp_main.py          # Точка входа для веб-интерфейса
├── migrations.py           # Управление миграциями
├── requirements.txt        # Зависимости Python
├── Dockerfile             # Конфигурация Docker
├── docker-compose.yml     # Оркестрация сервисов
└── README.md              # Документация проекта
```

### Основные компоненты

**Telegram Bot Module (`bot/`)** представляет собой ядро системы взаимодействия с пользователями через Telegram API. Модуль построен на базе библиотеки python-telegram-bot и включает несколько специализированных подмодулей. Основной файл `telegram_bot.py` содержит базовую конфигурацию бота и экспортирует глобальный объект бота для использования в веб-интерфейсе. Модуль `handlers.py` реализует основную логику обработки входящих сообщений, включая текстовые сообщения, фотографии и команды. Система поддерживает rate limiting для предотвращения спама и включает индикатор "бот печатает" для улучшения пользовательского опыта.

**RAG System (`retrieval/`)** реализует современный подход к поиску и генерации ответов на основе базы знаний. Система включает парсер документов `doc_parser.py`, который поддерживает PDF, DOCX и Excel форматы. Модуль `retriever.py` обеспечивает семантический поиск по векторной базе данных ChromaDB, а `reranker.py` применяет LLM-переранжирование для улучшения релевантности результатов. Система поддерживает кэширование результатов переранжирования для оптимизации производительности.

**Web Interface (`webapp/`)** предоставляет административный интерфейс для управления системой. Построен на Flask с использованием JWT аутентификации и ролевой модели доступа. Включает маршруты для управления активными чатами, загрузки документов в базу знаний, просмотра статистики и истории сообщений. Веб-интерфейс поддерживает rate limiting и включает защиту от CSRF атак.

**Storage Layer (`storage/`)** абстрагирует работу с различными системами хранения данных. После критических исправлений включает унифицированный модуль `database_unified.py`, который предоставляет единую точку доступа к PostgreSQL для всех компонентов системы. Модуль `database_sqlalchemy.py` содержит исправленную реализацию connection pooling и безопасного управления соединениями. Устаревший модуль `database.py` сохранен для совместимости, но не используется в продакшн среде.

**Database Monitoring (`utils/db_monitor.py`)** предоставляет комплексную систему мониторинга состояния базы данных и connection pool. Модуль отслеживает жизненный цикл соединений, предоставляет статистику использования пула и автоматически логирует проблемы с производительностью.

**Health Check System (`webapp/health.py`)** реализует endpoints для мониторинга состояния всех компонентов системы. Включает проверки базы данных, connection pool, интеграции с внешними API и специализированные endpoints для Kubernetes readiness и liveness probes.

**Controllers (`controllers/`)** содержат бизнес-логику системы, отделенную от слоя представления. Основной контроллер `query_controller.py` обрабатывает пользовательские запросы через RAG pipeline, а `broadcast.py` управляет системой рассылок для администраторов.

**Utilities (`utils/`)** включают вспомогательные модули для различных аспектов функциональности системы. Модуль `input_sanitization.py` обеспечивает безопасность входных данных, `language_detection.py` определяет язык пользователя, а `rate_limit.py` реализует ограничения частоты запросов как для Telegram, так и для веб-интерфейса.

### Точки входа и режимы запуска

Система поддерживает несколько режимов запуска через универсальную точку входа `run.py`:

**Режим "all"** запускает все компоненты системы одновременно, включая Telegram бота и веб-интерфейс. Этот режим подходит для простых развертываний или разработки.

**Режим "telegram"** запускает только Telegram бота без веб-интерфейса. Используется в контейнеризованных развертываниях, где веб-интерфейс запускается в отдельном контейнере.

**Режим "web"** запускает только веб-интерфейс без Telegram бота. Позволяет масштабировать веб-компонент независимо от бота.

Конфигурация режима запуска осуществляется через переменную окружения `RUN_MODE` или аргумент командной строки `--mode`. Система автоматически инициализирует базу данных при запуске любого режима.


## Модуль телеграм-бота

Модуль телеграм-бота представляет собой сложную систему обработки пользовательских взаимодействий, построенную на принципах event-driven архитектуры с использованием библиотеки python-telegram-bot версии 20.7.

### Архитектура обработки сообщений

Система обработки сообщений построена по принципу цепочки обработчиков (Chain of Responsibility pattern), где каждый тип сообщения проходит через соответствующую последовательность обработчиков.

**Основной обработчик текстовых сообщений** в `handlers.py` реализует многоуровневую логику обработки. Сначала система проверяет, является ли сообщение частью активного диалога с оператором через функцию `user_message_to_operator_handler()`. Если активная сессия с оператором существует, сообщение пересылается оператору без дальнейшей обработки ботом. Это обеспечивает бесшовный переход между автоматическими ответами и человеческой поддержкой.

Если сообщение не является частью диалога с оператором, система выполняет определение языка через `detect_and_set_language()` и сохраняет его в контексте пользователя. Поддерживаются русский и английский языки с автоматическим fallback на английский для неопределенных языков.

**Система санитизации входных данных** обрабатывает все пользовательские сообщения через `sanitize_input()` для предотвращения инъекций и других атак. Функция проверяет длину сообщения (максимум 3000 символов), удаляет потенциально опасные символы и паттерны, а также логирует подозрительные попытки ввода.

**Детектор приветствий** анализирует входящие сообщения на предмет приветственных фраз через `is_greeting()`. При обнаружении приветствия система отправляет предварительно настроенный ответ и завершает обработку, что позволяет экономить ресурсы на простых взаимодействиях.

**Система эскалации** автоматически анализирует сообщения на наличие ключевых слов, указывающих на желание пользователя общаться с человеком-оператором. Ключевые фразы включают "позови человека", "оператор", "зови человека", "help desk", "call a human", "human operator", "talk to human". При обнаружении таких фраз система проверяет возможность эскалации через `can_escalate()`, которая учитывает cooldown период в 15 минут между запросами эскалации от одного пользователя.

### Система индикации активности

Одной из важных особенностей системы является реализация индикатора "бот думает" через класс `ThinkingIndicator`. Этот компонент улучшает пользовательский опыт, показывая, что бот обрабатывает запрос, особенно для сложных запросов, требующих обращения к RAG системе.

**Механизм работы индикатора** включает отправку действия "typing" через Telegram API и временного сообщения "Думаю..." на соответствующем языке пользователя. После завершения обработки запроса временное сообщение заменяется финальным ответом, что создает ощущение непрерывного диалога.

**Локализация индикатора** поддерживает различные языки через систему `get_language_message()`, которая возвращает соответствующие фразы для каждого поддерживаемого языка. Для русского языка используется "Думаю...", для английского "Thinking...".

### Система диалогов и callback-обработка

Модуль `dialogues.py` реализует сложную систему интерактивных диалогов с использованием inline-клавиатур Telegram.

**Команда /support** предоставляет структурированное меню для категоризации запросов пользователей. Система создает inline-клавиатуру с опциями "Заказ", "Оплата", "Доставка" и "Другое", что позволяет операторам лучше понимать контекст обращения пользователя.

**Обработчик callback-запросов** `support_callback_handler()` обрабатывает нажатия на кнопки меню поддержки. При выборе категории система автоматически создает запрос эскалации к оператору с указанием выбранной категории, что помогает операторам приоритизировать и правильно маршрутизировать обращения.

**Система follow-up вопросов** реализует два режима работы: жесткий режим на основе предварительно настроенного словаря (`map` режим) и динамический режим с использованием LLM генерации (`llm` режим). Режим настраивается через переменную окружения `FOLLOWUP_MODE`.

В map режиме система использует файл `data/followup_map.json` для поиска предварительно настроенных follow-up вопросов на основе ключевых слов из пользовательского запроса. В llm режиме система генерирует follow-up вопросы динамически с использованием языковой модели, что обеспечивает более контекстуальные и релевантные предложения.

**Обработчик follow-up callback-запросов** `followup_callback_handler()` обрабатывает выбор пользователем предложенных вопросов. При выборе вопроса система автоматически обрабатывает его как новый пользовательский запрос через RAG pipeline и генерирует новые follow-up предложения, создавая цепочку связанных вопросов.

### Система обработки низкой уверенности

Система включает механизм обработки ответов с низким уровнем уверенности через `low_confidence_handler()`. Когда confidence score ответа падает ниже порогового значения (по умолчанию 0.7), система предлагает пользователю два варианта действий.

**Опция "Перефразировать вопрос"** позволяет пользователю переформулировать свой запрос для получения более точного ответа. Система отправляет соответствующее сообщение и ожидает новый запрос от пользователя.

**Опция "Связаться с оператором"** инициирует процесс эскалации к человеку-оператору. Система проверяет возможность эскалации и, при успехе, создает запрос оператору с контекстом исходного вопроса пользователя.

**Контекстная обработка** учитывает историю уровней уверенности пользователя. Система отслеживает последние три ответа для каждого пользователя и, если два или более ответов имеют низкий уровень уверенности, адаптирует генерацию follow-up вопросов для более эффективного решения проблемы пользователя.

### Система эскалации к операторам

Модуль `operator.py` реализует комплексную систему эскалации запросов к операторам-людям с поддержкой множественных операторов и управления сессиями.

**Механизм пересылки запросов** `forward_request_to_operator()` создает структурированный запрос оператору, включающий информацию о пользователе, текст сообщения или описание фото, категорию запроса (если указана) и inline-кнопки для принятия или отклонения запроса.

Система поддерживает отправку запросов множественным операторам одновременно через список `ADMIN_IDS` в конфигурации. Если отправка запроса хотя бы одному оператору успешна, пользователь получает подтверждение. В случае недоступности всех операторов пользователь получает соответствующее уведомление.

**Управление активными сессиями** осуществляется через глобальный словарь `ACTIVE_OPERATOR_SESSIONS`, который отслеживает соответствие между пользователями и операторами. Структура данных включает ID оператора и ID сессии в базе данных для каждого активного диалога.

**Обработчик callback-запросов операторов** `operator_callback()` управляет действиями операторов по принятию, отклонению и завершению сессий. При принятии запроса система проверяет, не принял ли уже другой оператор этот запрос, добавляет пользователя в активные сессии и уведомляет пользователя о начале диалога с оператором.

**Система сообщений оператор-пользователь** реализует двунаправленную коммуникацию. Функция `operator_message_handler()` обрабатывает сообщения от операторов и пересылает их пользователям с префиксом "Оператор:". Система поддерживает теги вида `#user_123` для указания конкретного пользователя при работе оператора с множественными сессиями.

**Завершение сессий и система оценок** автоматически запускается при нажатии оператором кнопки "Завершить сессию". Система обновляет статус сессии в базе данных, удаляет запись из активных сессий и отправляет пользователю запрос на оценку диалога с оператором через inline-клавиатуру с оценками от 1 до 5.

### Система обратной связи

Модуль `feedback.py` реализует комплексную систему сбора и обработки обратной связи от пользователей.

**Обработчик оценок** `rating_callback_handler()` обрабатывает выбор пользователем оценки от 1 до 5. Система сохраняет оценку в базе данных, связывая её с соответствующей сессией. Для низких оценок (1-3) система автоматически запрашивает дополнительную текстовую обратную связь для понимания причин неудовлетворенности.

**Обработчик текстовой обратной связи** `handle_feedback_message()` отслеживает пользователей, от которых ожидается дополнительная обратная связь после низкой оценки. Система использует глобальный словарь `WAITING_FEEDBACK` для связи пользователей с ID их оценок и автоматически сохраняет полученную обратную связь в базе данных.

**Интеграция с основным обработчиком** обеспечивается через вызов `handle_feedback_message()` в начале основного обработчика текстовых сообщений. Это позволяет системе корректно обрабатывать обратную связь до применения других логик обработки сообщений.

### Rate Limiting и безопасность

Система включает комплексные механизмы защиты от злоупотреблений и атак.

**Telegram Rate Limiting** реализован через декоратор `@telegram_rate_limit`, который применяется к основным обработчикам сообщений. Система отслеживает частоту запросов от каждого пользователя и применяет временные блокировки при превышении лимитов.

**Конфигурируемые лимиты** включают максимальное количество сообщений в секунду (`TELEGRAM_RATE_LIMIT_SECONDS`), максимальное количество нарушений (`TELEGRAM_RATE_LIMIT_MAX_VIOLATIONS`) и время блокировки (`TELEGRAM_RATE_LIMIT_BLOCK_SECONDS`).

**Интеграция с Redis** обеспечивает распределенное отслеживание лимитов в кластерных развертываниях. Система использует Redis для хранения счетчиков запросов и временных блокировок, что позволяет масштабировать бота горизонтально.

### Обработка ошибок и логирование

Система включает комплексную обработку ошибок и логирование для диагностики и мониторинга.

**Глобальный обработчик ошибок** `global_error_handler()` в `main.py` перехватывает все необработанные исключения в обработчиках бота и логирует их с полной трассировкой стека. Это обеспечивает стабильность работы бота даже при возникновении неожиданных ошибок.

**Структурированное логирование** использует модуль `logging` Python с настраиваемыми уровнями детализации. Система логирует входящие сообщения, результаты обработки, ошибки интеграции с внешними сервисами и действия операторов.

**Контекстное логирование** включает ID пользователя, временные метки и контекст обработки для каждого события, что упрощает диагностику проблем и анализ поведения пользователей.


## Система RAG и управления знаниями

Система Retrieval-Augmented Generation (RAG) представляет собой современную архитектуру для поиска и генерации ответов на основе корпоративной базы знаний. Система построена на принципах семантического поиска с использованием векторных представлений документов и LLM-переранжирования для улучшения релевантности результатов.

### Архитектура RAG pipeline

**Основной pipeline обработки запросов** реализован в `controllers/query_controller.py` и включает несколько этапов обработки. Первый этап включает получение релевантных документов из векторной базы данных через `retrieve_relevant_docs()`. Система извлекает топ-K наиболее семантически близких документов на основе эмбеддингов пользовательского запроса.

**Формирование контекста** происходит путем объединения найденных документов в структурированный контекст для языковой модели. Каждый документ включает метаданные об источнике, что позволяет модели генерировать более информативные ответы с указанием источников информации.

**Генерация ответа** осуществляется через интеграцию с OpenAI API с использованием сформированного контекста. Система использует специализированные системные промпты для корпоративного бота поддержки, которые инструктируют модель отвечать кратко и информативно, основываясь только на предоставленной информации.

**Оценка уверенности** включает анализ качества сгенерированного ответа и его соответствия найденным документам. Система возвращает как текст ответа, так и численную оценку уверенности, которая используется для принятия решений о необходимости эскалации или предложения альтернативных действий.

### Система парсинга документов

Модуль `retrieval/doc_parser.py` реализует универсальную систему извлечения текста из различных форматов документов.

**Парсер PDF документов** `parse_pdf()` использует библиотеку PyPDF2 для извлечения текста из PDF файлов. Система обрабатывает многостраничные документы, извлекая текст с каждой страницы и объединяя его в единый текстовый блок. Функция включает обработку ошибок для поврежденных или защищенных PDF файлов.

**Парсер DOCX документов** `parse_docx()` использует библиотеку python-docx для извлечения текста из документов Microsoft Word. Система обрабатывает все параграфы документа, сохраняя структуру текста и обеспечивая корректное извлечение форматированного содержимого.

**Парсер Excel документов** `parse_excel()` использует библиотеку openpyxl для извлечения данных из электронных таблиц. Система обрабатывает все листы книги Excel, извлекая данные из всех ячеек и формируя структурированный текстовый представление табличных данных.

**Универсальный интерфейс** `parse_document()` автоматически определяет тип документа по расширению файла и вызывает соответствующий парсер. Система поддерживает расширения .pdf, .docx, .xls, .xlsx и включает обработку неподдерживаемых форматов.

### Векторный поиск и индексация

Система использует ChromaDB для хранения векторных представлений документов и выполнения семантического поиска.

**Процесс индексации** включает разбиение документов на чанки оптимального размера, генерацию эмбеддингов для каждого чанка и сохранение их в векторной базе данных вместе с метаданными. Система поддерживает настраиваемые размеры чанков и стратегии разбиения для различных типов документов.

**Семантический поиск** реализован в `retrieval/retriever.py` через функцию `retrieve_relevant_docs()`. Система генерирует эмбеддинг пользовательского запроса и выполняет поиск наиболее близких векторов в ChromaDB. Результаты включают как текстовое содержимое чанков, так и метаданные об источниках.

**Конфигурируемые параметры поиска** включают количество возвращаемых документов (`top_k`), пороговые значения сходства и стратегии ранжирования результатов. Система поддерживает как базовый векторный поиск, так и гибридные подходы с комбинированием различных метрик сходства.

### LLM-переранжирование

Модуль `retrieval/reranker.py` реализует систему улучшения релевантности результатов поиска с использованием языковых моделей.

**Механизм переранжирования** работает в два этапа: сначала система получает больше документов из векторной базы (по умолчанию 10), чем требуется в финальном результате, затем применяет LLM для оценки релевантности каждого документа конкретному запросу пользователя.

**Функция оценки релевантности** `calculate_relevance_score()` использует специализированный промпт для языковой модели, который инструктирует её оценить релевантность фрагмента текста запросу по шкале от 1 до 5. Система использует низкую температуру (0.1) для обеспечения консистентности оценок.

**Кэширование результатов** реализовано через декоратор `@lru_cache` для функции `get_cached_relevance_score()`. Система кэширует оценки релевантности для пар запрос-документ, что значительно ускоряет повторные запросы и снижает нагрузку на OpenAI API.

**Фильтрация и ограничения** включают удаление документов с оценкой ниже порогового значения (`RERANKING_MIN_SCORE`, по умолчанию 4.0) и ограничение количества возвращаемых документов (`RERANKING_MAX_CHUNKS`, по умолчанию 3). Это обеспечивает высокое качество контекста для генерации ответов.

**Конфигурируемость системы** позволяет включать или отключать переранжирование через переменную `RERANKING_ENABLED`, выбирать модель для переранжирования через `RERANKING_MODEL` и настраивать размер кэша через `RERANKING_CACHE_SIZE`.

### Система follow-up вопросов

Система поддерживает два режима генерации follow-up вопросов для улучшения пользовательского опыта.

**Map режим** использует предварительно настроенный словарь в файле `data/followup_map.json`. Система анализирует ключевые слова в пользовательском запросе и ответе бота, затем ищет соответствующие follow-up вопросы в словаре. Этот подход обеспечивает быстрые и предсказуемые результаты, но требует ручной настройки словаря.

**LLM режим** использует языковую модель для динамической генерации follow-up вопросов на основе контекста диалога. Система передает модели исходный запрос пользователя, ответ бота и контекст о предыдущих взаимодействиях, получая персонализированные предложения вопросов.

**Контекстная адаптация** учитывает историю уверенности ответов пользователя. Если система обнаруживает, что пользователь получал ответы с низкой уверенностью, она адаптирует генерацию follow-up вопросов для более эффективного решения проблемы.

**Функция `get_followup_suggestions()`** в `utils/followup_manager.py` реализует логику выбора между режимами и обработки результатов. Система возвращает список предложенных вопросов или специальное сообщение о невозможности предложить релевантные вопросы.

### Управление базой знаний через веб-интерфейс

Веб-интерфейс предоставляет административные функции для управления корпоративной базой знаний.

**Загрузка документов** реализована в `webapp/ops/routes.py` через endpoint `/knowledge-base/upload`. Система поддерживает drag-and-drop загрузку файлов с автоматической валидацией типов и размеров. Загруженные файлы сохраняются в директории `DOCUMENTS_PATH` с безопасными именами через `secure_filename()`.

**Автоматическая индексация** запускается после успешной загрузки документа. Система автоматически парсит документ, разбивает его на чанки, генерирует эмбеддинги и сохраняет их в ChromaDB. Процесс включает обновление метаданных в реляционной базе данных для отслеживания загруженных документов.

**Управление документами** включает просмотр списка загруженных документов, их метаданных и возможность удаления. Система отслеживает информацию о загрузившем пользователе, времени загрузки и описании документа.

**Retry логика и обработка ошибок** обеспечивает надежность операций с базой данных. Система включает механизмы повторных попыток для операций с базой данных и graceful handling ошибок индексации документов.

### Интеграция с OpenAI API

Модуль `utils/openai_client.py` реализует безопасную интеграцию с OpenAI API с дополнительными слоями валидации и защиты.

**Класс OpenAIClient** инкапсулирует взаимодействие с OpenAI API через LangChain интерфейс. Система использует ChatOpenAI класс для обеспечения совместимости с различными версиями API и моделями.

**Метод `get_completion()`** обрабатывает запросы к языковой модели с комплексной валидацией входных и выходных данных. Система форматирует сообщения в правильном формате чата через `format_chat_messages()` и применяет валидацию ответов через `validate_response()`.

**Безопасность и санитизация** включает проверку ответов на наличие потенциальных секретов через `sanitize_environment_variables()` и фильтрацию подозрительных паттернов. Система логирует все подозрительные активности для последующего анализа.

**Обработка ошибок API** включает graceful degradation при недоступности OpenAI API. Система возвращает безопасные fallback ответы на соответствующем языке пользователя и логирует ошибки для диагностики.

**Функция `get_openai_client()`** предоставляет прямой доступ к OpenAI клиенту для специализированных операций, таких как переранжирование. Система поддерживает настройку различных моделей для разных задач через конфигурационные параметры.


## Веб-интерфейс и API

Веб-интерфейс системы представляет собой современное Flask-приложение с RESTful API архитектурой, JWT аутентификацией и ролевой моделью доступа. Система предоставляет административные функции для управления ботом, мониторинга активных диалогов и анализа статистики использования.

### Архитектура Flask приложения

**Основное приложение** создается через factory pattern в `webapp/app.py` с использованием функции `create_app()`. Этот подход обеспечивает гибкость конфигурации и упрощает тестирование различных конфигураций приложения.

**Конфигурация приложения** включает настройки для JWT токенов, секретных ключей, CORS политик и интеграции с базой данных. Система поддерживает различные конфигурации для development, staging и production сред через переменные окружения.

**Blueprint архитектура** организует функциональность в логические модули: `auth_bp` для аутентификации, `ops_bp` для операционных функций и `stats_bp` для статистики. Каждый blueprint регистрируется с соответствующим URL префиксом (`/api/auth`, `/api/ops`, `/api/stats`).

**Обработка ошибок** включает централизованные обработчики для HTTP ошибок 404 и 500. Система возвращает структурированные JSON ответы с соответствующими кодами состояния и сообщениями об ошибках.

**Маршруты веб-интерфейса** обслуживают HTML страницы для различных разделов административной панели: login, dashboard, active-chats, chat, knowledge-base, history и statistics. Система использует Tailwind CSS для современного и отзывчивого дизайна.

### Система аутентификации и авторизации

Модуль `webapp/auth/routes.py` реализует комплексную систему безопасности с JWT токенами и ролевой моделью доступа.

**Endpoint `/api/auth/login`** обрабатывает аутентификацию пользователей через POST запросы с JSON payload, содержащим username и password. Система валидирует учетные данные через `login_user()` функцию, которая проверяет хеш пароля с использованием bcrypt и генерирует JWT токен при успешной аутентификации.

**JWT токены** настроены для передачи в HTTP заголовке Authorization с префиксом Bearer. Система использует Flask-JWT-Extended для управления токенами с настраиваемым временем жизни через `JWT_ACCESS_TOKEN_EXPIRES` (по умолчанию 6 часов).

**Endpoint `/api/auth/check`** предоставляет механизм валидации активных токенов. Защищенный декоратором `@token_required`, этот endpoint возвращает информацию о текущем пользователе, включая ID, username и роль.

**Создание пользователей** через `/api/auth/users` доступно только администраторам и включает валидацию ролей (admin, operator, viewer), проверку уникальности username и безопасное хеширование паролей.

**Инициализация администратора** через `/api/auth/init-admin` позволяет создать первого администратора системы с использованием специального ключа инициализации. Этот механизм обеспечивает безопасную первоначальную настройку системы.

**Декораторы безопасности** `@token_required` и `@role_required` обеспечивают защиту endpoints и проверку прав доступа. Система автоматически извлекает информацию о пользователе из JWT токена и сохраняет её в Flask context (`g.user`).

### Операционные функции

Модуль `webapp/ops/routes.py` предоставляет основные операционные функции для управления активными диалогами и базой знаний.

**Управление активными чатами** реализовано через несколько endpoints:

Endpoint `/active-chats` возвращает список активных диалогов с пользователями, включая ожидающие ответа оператора и активные сессии с назначенными операторами. Система выполняет сложные SQL запросы для получения последних сообщений и метаданных диалогов.

Endpoint `/my-chats` предоставляет операторам список их активных сессий. Система фильтрует диалоги по ID текущего оператора из глобального словаря `ACTIVE_OPERATOR_SESSIONS`.

Endpoint `/chat/<user_id>/messages` возвращает историю сообщений для конкретного диалога. Доступ ограничен оператором, назначенным на данный диалог.

**Управление диалогами** включает функции принятия, обмена сообщениями и завершения диалогов:

Endpoint `/chat/<user_id>/accept` позволяет оператору принять ожидающий диалог. Система проверяет, что диалог не принят другим оператором, и обновляет глобальное состояние активных сессий.

Endpoint `/chat/<user_id>/message` обеспечивает отправку сообщений от оператора пользователю через Telegram API. Система добавляет префикс "Оператор:" к сообщениям и логирует все взаимодействия.

Endpoint `/chat/<user_id>/end` завершает активную сессию, обновляет статус в базе данных и автоматически отправляет пользователю запрос на оценку диалога.

**Управление базой знаний** реализовано через endpoint `/knowledge-base/upload`:

Система поддерживает загрузку документов с валидацией типов файлов и безопасными именами через `secure_filename()`. Загруженные файлы сохраняются в настраиваемой директории `DOCUMENTS_PATH`.

Автоматическая индексация включает парсинг документа через `parse_document()`, разбиение на чанки и сохранение в векторной базе данных через `store_document_chunks()`.

Retry логика обеспечивает надежность операций с базой данных через функцию `retry_db_operation()` с настраиваемым количеством попыток и экспоненциальной задержкой.

Система отслеживает метаданные документов в реляционной базе данных, включая имя файла, путь, описание, информацию о загрузившем пользователе и временные метки.

### Система статистики и аналитики

Модуль `webapp/stats/routes.py` предоставляет аналитические данные о работе системы поддержки.

**Основные метрики** включают количество обработанных запросов, средние уровни уверенности ответов, частоту эскалации к операторам и распределение оценок пользователей.

**Временные ряды** позволяют анализировать тренды использования системы по дням, неделям и месяцам. Система агрегирует данные из таблиц сообщений, сессий и оценок.

**Операторская аналитика** включает метрики производительности операторов, среднее время ответа, количество обработанных диалогов и средние оценки от пользователей.

**Экспорт данных** поддерживает различные форматы для интеграции с внешними аналитическими системами и создания отчетов.

### Rate Limiting для веб-интерфейса

Система включает защиту от злоупотреблений через декоратор `@web_rate_limit`, который применяется ко всем API endpoints.

**Конфигурируемые лимиты** включают максимальное количество запросов в минуту (`WEB_RATE_LIMIT_REQUESTS`, по умолчанию 100) и временное окно для подсчета (`WEB_RATE_LIMIT_MINUTES`, по умолчанию 1 минута).

**Интеграция с Redis** обеспечивает распределенное отслеживание лимитов в кластерных развертываниях. Система использует IP адрес клиента как ключ для отслеживания запросов.

**Graceful handling** превышения лимитов возвращает HTTP 429 статус с информативными сообщениями об ошибке и времени до сброса лимита.

### Интеграция с Telegram Bot

Веб-интерфейс тесно интегрирован с Telegram ботом для обеспечения бесшовного взаимодействия между операторами и пользователями.

**Глобальный объект бота** импортируется из `bot.telegram_bot` и используется для отправки сообщений пользователям через веб-интерфейс. Это обеспечивает единообразие взаимодействия независимо от канала коммуникации.

**Синхронизация состояния** между веб-интерфейсом и ботом осуществляется через глобальные словари `ACTIVE_OPERATOR_SESSIONS` и `OPERATOR_REQUESTS`. Эти структуры данных обеспечивают консистентность информации о активных диалогах.

**Уведомления операторов** о новых запросах пользователей отправляются как через Telegram, так и отображаются в веб-интерфейсе в реальном времени.

### Безопасность веб-интерфейса

Система включает множественные слои безопасности для защиты административного интерфейса.

**HTTPS enforcement** обеспечивается на уровне reverse proxy или load balancer в продакшн развертываниях.

**CSRF защита** реализована через проверку токенов в формах и AJAX запросах.

**XSS защита** включает санитизацию всех пользовательских данных перед отображением в веб-интерфейсе.

**SQL Injection защита** обеспечивается через использование SQLAlchemy ORM с параметризованными запросами.

**Валидация входных данных** применяется ко всем API endpoints с проверкой типов, размеров и форматов данных.

**Логирование безопасности** отслеживает все попытки аутентификации, изменения ролей пользователей и подозрительные активности.


## Система хранения данных

Система использует унифицированную архитектуру хранения данных на базе PostgreSQL, объединяющую реляционную базу данных для структурированной информации, векторную базу данных для семантического поиска и файловую систему для хранения документов. После критических исправлений система полностью мигрирована на PostgreSQL для обеспечения стабильности и масштабируемости.

### Архитектура базы данных

**Унифицированная система доступа к данным** реализована через модуль `storage/database_unified.py`, который предоставляет единую абстракцию для работы с PostgreSQL базой данных. Этот подход устраняет проблемы с дублированием данных между компонентами системы и обеспечивает консистентность информации между телеграм-ботом и веб-интерфейсом.

**Автоматическая инициализация схемы** выполняется через функцию `ensure_db_exists()`, которая создает все необходимые таблицы при первом запуске системы. Система проверяет существование директории базы данных и создает её при необходимости, обеспечивая корректную инициализацию в контейнеризованных средах.

**Схема базы данных** включает пять основных таблиц, оптимизированных для различных аспектов функциональности системы:

Таблица `messages` хранит всю историю взаимодействий между пользователями и ботом. Структура включает уникальный идентификатор сообщения, ID пользователя, временную метку, текст сообщения пользователя, ответ бота, оценку уверенности (confidence score) и язык взаимодействия. Эта таблица служит основой для аналитики и улучшения качества ответов системы.

Таблица `sessions` отслеживает сессии взаимодействия пользователей с системой поддержки. Каждая сессия включает ID пользователя, время начала и окончания, язык пользователя и временную метку последней эскалации к оператору. Система использует эту информацию для управления cooldown периодами эскалации и аналитики использования.

Таблица `ratings` хранит оценки пользователей для завершенных сессий с операторами. Структура связывает оценку (от 1 до 5) с соответствующей сессией через внешний ключ, включая временную метку для анализа трендов удовлетворенности пользователей.

Таблица `feedback` содержит текстовую обратную связь от пользователей, особенно для низких оценок. Система автоматически запрашивает дополнительную обратную связь для оценок 1-3, что помогает выявлять проблемы и улучшать качество обслуживания.

Таблица `suspicious_inputs` логирует потенциально вредоносные или подозрительные попытки ввода. Система отслеживает паттерны атак, предпринятые действия и временные метки для анализа безопасности и улучшения защитных механизмов.

### SQLAlchemy ORM реализация

Модуль `storage/database_sqlalchemy.py` предоставляет объектно-реляционное отображение для работы с PostgreSQL в продакшн средах.

**Конфигурация подключения** использует переменные окружения для настройки параметров базы данных: `DB_HOST`, `DB_PORT`, `DB_NAME`, `DB_USER`, `DB_PASSWORD`. Система поддерживает connection pooling и настраиваемые таймауты для обеспечения стабильности в высоконагруженных средах.

**Модели данных** определены как SQLAlchemy классы с соответствующими отношениями между таблицами. Система использует декларативный подход с автоматической генерацией первичных ключей и индексов для оптимизации производительности запросов.

**Сессии и транзакции** управляются через context managers для обеспечения корректного закрытия соединений и rollback при ошибках. Система включает retry логику для обработки временных сбоев сети или базы данных.

**Миграции схемы** поддерживаются через модуль `migrations/` с версионированием изменений схемы. Система автоматически применяет необходимые миграции при запуске и поддерживает rollback для критических изменений.

### Функции доступа к данным

Система предоставляет высокоуровневые функции для работы с данными, абстрагирующие детали реализации хранения.

**Функция `save_message()`** сохраняет взаимодействия пользователя с ботом в базу данных. Параметры включают ID пользователя, текст сообщения, ответ бота, оценку уверенности и язык. Система автоматически добавляет временную метку в ISO формате для консистентности временных зон.

**Функция `get_user_session()`** извлекает информацию о текущей сессии пользователя или создает новую при необходимости. Система отслеживает активные сессии для управления эскалацией и cooldown периодами.

**Функция `save_rating()`** сохраняет оценки пользователей для завершенных сессий с операторами. Система валидирует диапазон оценок (1-5) и связывает их с соответствующими сессиями через внешние ключи.

**Функция `save_feedback()`** сохраняет текстовую обратную связь от пользователей. Система автоматически связывает обратную связь с соответствующими оценками для комплексного анализа удовлетворенности.

**Функция `log_suspicious_input()`** записывает подозрительные попытки ввода для анализа безопасности. Система отслеживает паттерны атак, IP адреса и предпринятые защитные действия.

### Retry логика и отказоустойчивость

Система включает комплексные механизмы обеспечения надежности операций с базой данных.

**Функция `retry_db_operation()`** реализует экспоненциальную задержку для повторных попыток операций с базой данных. Система поддерживает настраиваемое количество попыток (по умолчанию 3) и максимальную задержку между попытками.

**Обработка специфических исключений** включает различные стратегии для разных типов ошибок: временные сетевые сбои, блокировки базы данных, нарушения ограничений целостности и исчерпание пула соединений.

**Graceful degradation** обеспечивает продолжение работы системы даже при частичной недоступности базы данных. Критические операции, такие как сохранение сообщений, имеют приоритет над аналитическими запросами.

**Мониторинг и алертинг** включает логирование всех ошибок базы данных с детальной информацией для диагностики. Система отслеживает частоту ошибок и может автоматически переключаться на резервные механизмы хранения.

### Векторная база данных ChromaDB

Система использует ChromaDB для хранения векторных представлений документов и выполнения семантического поиска.

**Конфигурация ChromaDB** включает настройку пути к базе данных через переменную `CHROMA_DB_PATH` и выбор модели эмбеддингов. Система поддерживает как локальное хранение, так и распределенные конфигурации для масштабирования.

**Коллекции документов** организованы по типам и источникам для оптимизации поиска. Система автоматически создает индексы для метаданных документов, включая источник, дату загрузки и тип контента.

**Управление эмбеддингами** включает автоматическую генерацию векторных представлений при загрузке документов и обновление индексов при изменении содержимого. Система поддерживает различные модели эмбеддингов для оптимизации под конкретные домены знаний.

**Оптимизация производительности** включает настройку размеров батчей для индексации, кэширование часто запрашиваемых векторов и компрессию данных для экономии дискового пространства.

### История запросов и аналитика

Модуль `storage/request_history.py` предоставляет специализированные функции для анализа истории взаимодействий пользователей.

**Функция `get_user_request_history()`** извлекает историю запросов конкретного пользователя с настраиваемыми фильтрами по времени, типу запроса и уровню уверенности ответов. Система поддерживает пагинацию для обработки больших объемов данных.

**Аналитические запросы** включают агрегацию данных по различным измерениям: временные тренды, распределение уровней уверенности, частота эскалации и анализ удовлетворенности пользователей.

**Экспорт данных** поддерживает различные форматы (JSON, CSV, Excel) для интеграции с внешними аналитическими системами и создания отчетов для менеджмента.

**Очистка старых данных** включает настраиваемые политики retention для управления размером базы данных. Система может автоматически архивировать или удалять старые записи в соответствии с корпоративными политиками хранения данных.

### Резервное копирование и восстановление

Система включает механизмы защиты данных и восстановления после сбоев.

**Автоматическое резервное копирование** SQLite базы данных выполняется через настраиваемые интервалы. Система создает инкрементальные копии для экономии дискового пространства и времени.

**Экспорт векторной базы** ChromaDB поддерживается через специализированные утилиты для создания полных копий индексов и метаданных. Система может восстанавливать векторные индексы из резервных копий документов при необходимости.

**Валидация целостности данных** включает проверку консистентности между реляционной и векторной базами данных. Система автоматически обнаруживает и исправляет расхождения в метаданных документов.

**Процедуры восстановления** документированы для различных сценариев сбоев: повреждение базы данных, потеря векторных индексов, несоответствие версий схемы и восстановление после катастрофических сбоев.

### Мониторинг производительности

Система включает комплексный мониторинг производительности операций с базой данных.

**Метрики производительности** отслеживают время выполнения запросов, использование индексов, размеры таблиц и частоту операций. Система логирует медленные запросы для оптимизации.

**Анализ использования ресурсов** включает мониторинг использования дискового пространства, памяти для кэширования и сетевого трафика для распределенных конфигураций.

**Автоматическая оптимизация** включает периодическую дефрагментацию индексов, обновление статистики запросов и очистку временных данных для поддержания оптимальной производительности.

### Мониторинг соединений с базой данных

Модуль `utils/db_monitor.py` предоставляет комплексную систему мониторинга состояния базы данных и connection pool.

**Отслеживание жизненного цикла соединений** реализовано через SQLAlchemy event listeners, которые логируют каждое открытие и закрытие соединения с базой данных. Система записывает временные метки, идентификаторы соединений и контекстную информацию для анализа паттернов использования.

**Функция `get_connection_stats()`** предоставляет детальную статистику состояния connection pool в реальном времени:

- `size()` - текущий размер пула соединений
- `checked_in()` - количество доступных соединений в пуле  
- `checked_out()` - количество активно используемых соединений
- `overflow()` - количество дополнительных соединений сверх базового размера пула
- `invalid()` - количество недействительных соединений, требующих пересоздания

**Автоматическое логирование проблем** включает обнаружение утечек соединений, превышения лимитов пула и длительных блокировок. Система может автоматически уведомлять администраторов о критических проблемах через настраиваемые каналы алертинга.

**Интеграция с системой логирования** обеспечивает структурированную запись всех событий мониторинга в формате, совместимом с внешними системами анализа логов и мониторинга.

### Health Check система

Модуль `webapp/health.py` реализует комплексную систему проверки состояния всех компонентов системы для обеспечения надежности и упрощения мониторинга в продакшн средах.

**Endpoint `/health`** предоставляет общий статус системы с проверкой всех критических компонентов. Проверка включает доступность базы данных, состояние connection pool, доступность Redis для кэширования и статус интеграции с внешними API. Ответ содержит общий статус (`healthy`/`unhealthy`) и детальную информацию о каждом компоненте.

**Endpoint `/health/db`** выполняет специализированную проверку состояния базы данных с выполнением тестового запроса `SELECT 1` для валидации подключения. Система возвращает детальную статистику connection pool, время выполнения тестового запроса и информацию о последних ошибках подключения.

**Endpoint `/health/db/connections`** предоставляет специализированный мониторинг состояния connection pool с детальной статистикой использования соединений. Этот endpoint особенно полезен для диагностики проблем с производительностью и выявления утечек соединений.

**Kubernetes integration endpoints** обеспечивают интеграцию с системами оркестрации контейнеров:

- `/health/ready` - readiness probe, проверяющий готовность системы к обработке запросов
- `/health/live` - liveness probe, проверяющий жизнеспособность системы и необходимость перезапуска

**Настраиваемые пороговые значения** позволяют адаптировать health checks под специфические требования среды развертывания. Система поддерживает настройку таймаутов, критических значений метрик и частоты проверок.

**Интеграция с мониторингом** обеспечивает совместимость с популярными системами мониторинга, включая Prometheus, Grafana, Nagios и cloud-native решения. Health check endpoints возвращают метрики в стандартизированных форматах для автоматической обработки.

**Алертинг и уведомления** настроены для критических метрик производительности: превышение времени выполнения запросов, исчерпание дискового пространства и ошибки подключения к базе данных.


## Утилиты и вспомогательные модули

Система включает обширный набор утилит и вспомогательных модулей, которые обеспечивают безопасность, производительность и удобство использования основных компонентов. Эти модули реализуют cross-cutting concerns и предоставляют переиспользуемую функциональность для всех слоев приложения.

### Система безопасности и валидации

**Модуль санитизации входных данных** `utils/input_sanitization.py` реализует многоуровневую защиту от различных типов атак и злоупотреблений.

Функция `sanitize_input()` выполняет комплексную очистку пользовательского ввода. Система проверяет длину сообщения с максимальным лимитом в 3000 символов для предотвращения DoS атак через чрезмерно длинные сообщения. Функция удаляет потенциально опасные символы, включая управляющие символы, HTML теги и специальные последовательности, которые могут использоваться для инъекций.

Детектор подозрительных паттернов анализирует входные данные на наличие признаков различных типов атак. Система распознает попытки SQL инъекций через паттерны вроде `SELECT`, `DROP`, `INSERT`, `UPDATE` в различных регистрах. XSS атаки обнаруживаются через поиск HTML тегов `<script>`, `<iframe>`, `<object>` и JavaScript событий. Command injection попытки выявляются через поиск системных команд и специальных символов командной строки.

Функция `log_suspicious_input()` автоматически записывает все подозрительные попытки ввода в базу данных для последующего анализа. Система отслеживает IP адреса, временные метки, типы обнаруженных атак и предпринятые защитные действия.

**Модуль валидации ответов** `utils/response_validation.py` обеспечивает безопасность генерируемых ботом ответов.

Функция `validate_response()` проверяет ответы языковой модели на наличие потенциально опасного или неподходящего контента. Система фильтрует ответы, содержащие личную информацию, финансовые данные, медицинские советы или другой контент, который может нарушать политики конфиденциальности или безопасности.

Функция `sanitize_environment_variables()` предотвращает утечку конфиденциальной информации через ответы модели. Система сканирует ответы на наличие паттернов, похожих на API ключи, пароли, токены доступа и другие секретные данные, заменяя их безопасными заглушками.

Функция `format_chat_messages()` обеспечивает корректное форматирование сообщений для языковых моделей, предотвращая prompt injection атаки через специально сформированные системные промпты или пользовательские сообщения.

### Система определения языка и локализации

**Модуль определения языка** `utils/language_detection.py` реализует автоматическое распознавание языка пользователя для обеспечения многоязычной поддержки.

Функция `detect_language()` анализирует текст сообщения пользователя и определяет наиболее вероятный язык. Система использует статистические методы анализа частоты символов, характерных для различных языков, и поддерживает русский и английский языки с возможностью расширения.

Алгоритм определения языка учитывает не только отдельные символы, но и биграммы и триграммы, характерные для конкретных языков. Система включает специальную обработку смешанных текстов, где пользователь может использовать несколько языков в одном сообщении.

Функция `detect_and_set_language()` интегрирует определение языка с контекстом пользователя в Telegram боте. Система сохраняет определенный язык в user_data для последующего использования в генерации ответов и интерфейсных сообщений.

**Система локализации сообщений** обеспечивает поддержку множественных языков для системных сообщений, уведомлений и интерфейсных элементов. Функция `get_language_message()` возвращает локализованные версии стандартных фраз на основе языка пользователя.

### Rate Limiting и защита от злоупотреблений

**Модуль rate limiting** `utils/rate_limit.py` реализует гибкую систему ограничения частоты запросов для различных компонентов системы.

Декоратор `@telegram_rate_limit` применяется к обработчикам Telegram бота для предотвращения спама и DoS атак. Система отслеживает количество сообщений от каждого пользователя в настраиваемом временном окне и применяет временные блокировки при превышении лимитов.

Конфигурируемые параметры включают максимальное количество сообщений в секунду (`TELEGRAM_RATE_LIMIT_SECONDS`), максимальное количество нарушений до блокировки (`TELEGRAM_RATE_LIMIT_MAX_VIOLATIONS`) и продолжительность блокировки (`TELEGRAM_RATE_LIMIT_BLOCK_SECONDS`).

Декоратор `@web_rate_limit` защищает веб-интерфейс от злоупотреблений API. Система использует IP адрес клиента для отслеживания запросов и поддерживает различные лимиты для различных типов операций.

**Интеграция с Redis** обеспечивает распределенное отслеживание лимитов в кластерных развертываниях. Система использует Redis для хранения счетчиков запросов, временных блокировок и метаданных о нарушениях.

Функция `check_rate_limit()` предоставляет программный интерфейс для проверки лимитов без применения блокировок. Это позволяет системе адаптивно изменять поведение в зависимости от текущей нагрузки.

### Система управления follow-up вопросами

**Модуль управления follow-up** `utils/followup_manager.py` реализует интеллектуальную систему предложения дополнительных вопросов пользователям.

Функция `get_followup_suggestions()` поддерживает два режима работы: map режим с предварительно настроенным словарем и LLM режим с динамической генерацией.

В map режиме система использует файл `data/followup_map.json` для поиска релевантных follow-up вопросов. Алгоритм анализирует ключевые слова в пользовательском запросе и ответе бота, затем ищет соответствующие записи в словаре. Система поддерживает нечеткое сопоставление и синонимы для улучшения качества предложений.

В LLM режиме система генерирует follow-up вопросы динамически с использованием языковой модели. Функция `generate_llm_followup()` формирует специализированный промпт, включающий контекст диалога, исходный запрос пользователя и ответ бота, затем запрашивает у модели предложения релевантных дополнительных вопросов.

**Контекстная адаптация** учитывает историю взаимодействий пользователя с системой. Функция `adapt_followup_for_low_confidence()` модифицирует генерацию follow-up вопросов для пользователей, которые получали ответы с низкой уверенностью, предлагая более базовые или альтернативные формулировки вопросов.

Система кэширования follow-up предложений снижает нагрузку на языковую модель для часто повторяющихся запросов. Кэш использует комбинацию пользовательского запроса и ответа бота как ключ для хранения предварительно сгенерированных предложений.

### Детектор приветствий и базовых запросов

**Модуль детектора приветствий** `utils/greeting_detector.py` оптимизирует обработку простых взаимодействий с пользователями.

Функция `is_greeting()` анализирует входящие сообщения на предмет приветственных фраз и возвращает булево значение. Система поддерживает множественные языки и различные формы приветствий, включая формальные и неформальные варианты.

Алгоритм использует комбинацию точного сопоставления и нечеткого поиска для обнаружения приветствий в различных формах. Система учитывает опечатки, сокращения и эмоциональные выражения, характерные для неформального общения.

**Предварительно настроенные ответы** для приветствий позволяют системе быстро отвечать на простые запросы без обращения к RAG pipeline или языковой модели. Это значительно снижает нагрузку на систему и улучшает время отклика для базовых взаимодействий.

Система поддерживает персонализацию приветственных ответов на основе времени суток, истории взаимодействий пользователя и настроек корпоративного стиля общения.

### Индикатор активности и пользовательский опыт

**Модуль индикатора активности** `utils/thinking_indicator.py` улучшает пользовательский опыт во время обработки сложных запросов.

Класс `ThinkingIndicator` управляет отображением индикатора "бот думает" в Telegram. Система отправляет действие "typing" через Telegram API и временное сообщение на соответствующем языке пользователя.

Механизм работы включает создание временного сообщения с текстом "Думаю..." или "Thinking..." в зависимости от языка пользователя. После завершения обработки запроса система заменяет временное сообщение финальным ответом, создавая ощущение непрерывного диалога.

**Адаптивное время отображения** индикатора зависит от сложности запроса. Система может показывать индикатор дольше для запросов, требующих обращения к RAG системе или сложной обработки языковой моделью.

Функция `show_thinking()` инкапсулирует логику отображения индикатора и может использоваться как context manager для автоматического управления жизненным циклом индикатора.

### Утилиты для работы с сообщениями

**Модуль утилит сообщений** `utils/message_utils.py` предоставляет вспомогательные функции для обработки и форматирования сообщений.

Функция `format_message_for_operator()` подготавливает сообщения пользователей для отображения операторам. Система добавляет контекстную информацию, включая ID пользователя, временные метки и метаданные о предыдущих взаимодействиях.

Функция `extract_user_id_from_tag()` обрабатывает теги вида `#user_123` в сообщениях операторов для определения целевого пользователя при работе с множественными активными диалогами.

**Система форматирования ответов** обеспечивает консистентность стиля сообщений от бота. Функции включают добавление префиксов для сообщений операторов, форматирование списков и таблиц, и адаптацию длины сообщений под ограничения Telegram API.

Функция `split_long_message()` автоматически разбивает длинные ответы на несколько сообщений, соблюдая лимиты Telegram и сохраняя читаемость контента.

### Система логирования и мониторинга

**Централизованное логирование** настроено через стандартный модуль `logging` Python с настраиваемыми уровнями детализации и форматами вывода.

Конфигурация логирования включает различные handlers для файлового логирования, консольного вывода и потенциальной интеграции с внешними системами мониторинга. Система поддерживает ротацию логов и сжатие старых файлов для управления дисковым пространством.

**Структурированное логирование** использует JSON формат для машинной обработки логов. Каждое событие включает временную метку, уровень логирования, модуль источника, ID пользователя (если применимо) и детальное описание события.

Система логирует критические события, включая ошибки интеграции с внешними сервисами, подозрительные активности пользователей, превышения rate limits и проблемы производительности.

**Метрики производительности** отслеживаются через специализированные логи, включающие время выполнения запросов, использование памяти, частоту обращений к различным компонентам системы и статистику успешности операций.

### Интеграция с внешними сервисами

**Модуль CRM интеграции** `services/crm_client.py` предоставляет интерфейс для интеграции с внешними CRM системами.

Класс `CRMClient` абстрагирует взаимодействие с различными CRM платформами через унифицированный API. Система поддерживает создание тикетов поддержки, обновление статусов клиентов и синхронизацию контактной информации.

**Конфигурируемые адаптеры** позволяют системе работать с различными CRM системами без изменения основного кода. Система поддерживает популярные платформы, включая Salesforce, HubSpot, Zendesk и custom REST API.

Функция `create_support_ticket()` автоматически создает тикеты в CRM системе при эскалации запросов к операторам. Система передает контекст диалога, категорию проблемы и приоритет для корректной обработки в CRM.

**Retry логика и обработка ошибок** обеспечивает надежность интеграции с внешними сервисами. Система включает экспоненциальную задержку для повторных попыток, circuit breaker pattern для защиты от каскадных сбоев и graceful degradation при недоступности CRM.

### Система миграций и обновлений

**Модуль миграций** `migrations/` управляет версионированием схемы базы данных и обновлениями системы.

Система поддерживает автоматическое применение миграций при запуске приложения. Каждая миграция включает функции `upgrade()` и `downgrade()` для прямого и обратного применения изменений схемы.

**Миграция follow-up расширений** `migrations/followup_extension.py` демонстрирует процесс добавления новой функциональности к существующей системе. Миграция добавляет поддержку расширенных follow-up вопросов с метаданными и аналитикой.

Система отслеживает примененные миграции в специальной таблице `schema_migrations` для предотвращения повторного применения и обеспечения консистентности между различными экземплярами приложения.


## Конфигурация и настройки

Система использует централизованную конфигурацию через модуль `config.py`, который объединяет переменные окружения, значения по умолчанию и валидацию параметров. Архитектура конфигурации обеспечивает гибкость развертывания в различных средах без изменения кода приложения.

### Структура конфигурации

**Основные параметры системы** включают критически важные настройки для работы всех компонентов:

Переменная `TELEGRAM_BOT_TOKEN` содержит токен для взаимодействия с Telegram Bot API. Система требует обязательного указания этого параметра через переменную окружения для обеспечения безопасности. Отсутствие токена приводит к ошибке инициализации бота.

Переменная `OPENAI_API_KEY` содержит ключ доступа к OpenAI API для генерации ответов и переранжирования документов. Система поддерживает как прямое указание ключа, так и чтение из файла для повышенной безопасности в контейнеризованных средах.

Список `ADMIN_IDS` определяет Telegram ID администраторов и операторов системы. Эти пользователи получают уведомления о запросах эскалации и имеют доступ к административным функциям бота. Система поддерживает множественных администраторов для обеспечения круглосуточной поддержки.

**Параметры базы данных** настраивают подключение к различным системам хранения:

Переменная `DATABASE_PATH` определяет путь к SQLite базе данных для простых развертываний. По умолчанию используется `data/bot_database.db` с автоматическим созданием директории при необходимости.

Параметры PostgreSQL (`DB_HOST`, `DB_PORT`, `DB_NAME`, `DB_USER`, `DB_PASSWORD`) настраивают подключение к продакшн базе данных. Система автоматически переключается на PostgreSQL при наличии соответствующих переменных окружения.

Переменная `CHROMA_DB_PATH` определяет расположение векторной базы данных ChromaDB. По умолчанию используется `data/chroma_db/` с автоматической инициализацией при первом запуске.

### Конфигурация AI и NLP компонентов

**Параметры языковых моделей** настраивают взаимодействие с OpenAI API:

Переменная `OPENAI_MODEL` определяет основную модель для генерации ответов (по умолчанию `gpt-3.5-turbo`). Система поддерживает все модели OpenAI Chat Completions API, включая GPT-4 для повышенного качества ответов.

Переменная `RERANKING_MODEL` настраивает модель для переранжирования документов (по умолчанию `gpt-4o`). Использование более мощной модели для переранжирования улучшает релевантность результатов поиска.

Параметр `CONFIDENCE_THRESHOLD` определяет пороговое значение уверенности для автоматических ответов (по умолчанию 0.7). Ответы с уверенностью ниже этого значения инициируют предложение эскалации к оператору.

**Настройки RAG системы** контролируют поведение поиска и генерации:

Переменная `RERANKING_ENABLED` включает или отключает LLM-переранжирование результатов поиска. Отключение переранжирования ускоряет обработку запросов, но может снизить качество ответов.

Параметр `RERANKING_MIN_SCORE` устанавливает минимальную оценку релевантности для включения документа в контекст (по умолчанию 4.0 из 5.0).

Переменная `RERANKING_MAX_CHUNKS` ограничивает количество документов в контексте для генерации ответа (по умолчанию 3). Увеличение этого значения может улучшить полноту ответов, но увеличивает стоимость API вызовов.

Параметр `RERANKING_CACHE_SIZE` настраивает размер LRU кэша для результатов переранжирования (по умолчанию 1000). Кэширование значительно ускоряет повторные запросы.

### Настройки безопасности и rate limiting

**Параметры Telegram rate limiting** защищают систему от спама и DoS атак:

Переменная `TELEGRAM_RATE_LIMIT_SECONDS` определяет временное окно для подсчета сообщений (по умолчанию 60 секунд). Система отслеживает количество сообщений от каждого пользователя в этом окне.

Параметр `TELEGRAM_RATE_LIMIT_MAX_VIOLATIONS` устанавливает максимальное количество нарушений до блокировки пользователя (по умолчанию 5). Система применяет прогрессивные ограничения для повторных нарушителей.

Переменная `TELEGRAM_RATE_LIMIT_BLOCK_SECONDS` определяет продолжительность блокировки пользователя (по умолчанию 300 секунд). Заблокированные пользователи получают информативные сообщения о причине блокировки.

**Параметры веб-интерфейса rate limiting** защищают API от злоупотреблений:

Переменная `WEB_RATE_LIMIT_REQUESTS` устанавливает максимальное количество запросов в минуту (по умолчанию 100). Система отслеживает запросы по IP адресу клиента.

Параметр `WEB_RATE_LIMIT_MINUTES` определяет временное окно для подсчета запросов (по умолчанию 1 минута). Система использует скользящее окно для более точного контроля.

**Настройки JWT аутентификации** обеспечивают безопасность веб-интерфейса:

Переменная `JWT_SECRET_KEY` содержит секретный ключ для подписи JWT токенов. Система требует обязательного указания этого параметра для обеспечения безопасности аутентификации.

Параметр `JWT_ACCESS_TOKEN_EXPIRES` определяет время жизни токенов доступа (по умолчанию 6 часов). Короткое время жизни токенов повышает безопасность, но требует более частой повторной аутентификации.

### Конфигурация follow-up системы

**Режимы работы follow-up** настраиваются через переменную `FOLLOWUP_MODE`:

Режим `map` использует предварительно настроенный словарь в файле `data/followup_map.json`. Этот режим обеспечивает быстрые и предсказуемые результаты, но требует ручной настройки словаря для каждого домена знаний.

Режим `llm` использует языковую модель для динамической генерации follow-up вопросов. Этот режим обеспечивает более контекстуальные предложения, но увеличивает нагрузку на OpenAI API и время отклика.

**Параметры follow-up генерации** контролируют качество и количество предложений:

Переменная `FOLLOWUP_MAX_SUGGESTIONS` ограничивает количество предлагаемых вопросов (по умолчанию 3). Оптимальное количество обеспечивает выбор без перегрузки пользователя опциями.

Параметр `FOLLOWUP_MIN_CONFIDENCE` устанавливает минимальную уверенность для генерации follow-up вопросов. Система не предлагает дополнительные вопросы для ответов с очень низкой уверенностью.

### Настройки файловой системы и путей

**Пути к директориям данных** настраиваются через соответствующие переменные:

Переменная `DOCUMENTS_PATH` определяет директорию для хранения загруженных документов (по умолчанию `data/documents/`). Система автоматически создает директорию и настраивает права доступа.

Параметр `LOGS_PATH` настраивает расположение файлов логов (по умолчанию `logs/`). Система поддерживает ротацию логов и автоматическую очистку старых файлов.

Переменная `STATIC_PATH` определяет директорию для статических файлов веб-интерфейса. Система обслуживает CSS, JavaScript и изображения из этой директории.

**Ограничения файлов** обеспечивают безопасность и производительность:

Параметр `MAX_FILE_SIZE` устанавливает максимальный размер загружаемых документов (по умолчанию 10 МБ). Система проверяет размер файлов до начала обработки.

Переменная `ALLOWED_EXTENSIONS` определяет список разрешенных расширений файлов для загрузки. По умолчанию поддерживаются PDF, DOCX, XLS и XLSX форматы.

### Конфигурация Redis и кэширования

**Параметры подключения к Redis** настраивают интеграцию с системой кэширования:

Переменная `REDIS_HOST` определяет адрес Redis сервера (по умолчанию `localhost`). Система поддерживает как локальные, так и удаленные Redis инстансы.

Параметры `REDIS_PORT` и `REDIS_DB` настраивают порт подключения (по умолчанию 6379) и номер базы данных (по умолчанию 0).

Переменная `REDIS_PASSWORD` содержит пароль для аутентификации в Redis. Система поддерживает как защищенные, так и открытые Redis конфигурации.

**Настройки кэширования** оптимизируют производительность системы:

Параметр `CACHE_TTL` определяет время жизни кэшированных данных (по умолчанию 3600 секунд). Система автоматически обновляет устаревшие записи кэша.

Переменная `CACHE_MAX_SIZE` ограничивает размер кэша в памяти для предотвращения исчерпания ресурсов.

### Настройки логирования и мониторинга

**Уровни логирования** настраиваются через переменную `LOG_LEVEL`:

Уровень `DEBUG` включает детальную информацию о работе всех компонентов системы. Используется в development среде для диагностики проблем.

Уровень `INFO` логирует основные события системы, включая обработку запросов, эскалацию к операторам и административные действия.

Уровень `WARNING` записывает потенциальные проблемы, которые не критичны для работы системы, но требуют внимания.

Уровень `ERROR` логирует ошибки, которые влияют на функциональность системы, но не приводят к полному отказу.

**Форматы логирования** поддерживают различные выходные форматы:

Формат `JSON` обеспечивает структурированное логирование для машинной обработки и интеграции с системами мониторинга.

Формат `TEXT` предоставляет человеко-читаемые логи для разработки и отладки.

**Ротация логов** настраивается через соответствующие параметры:

Переменная `LOG_MAX_SIZE` определяет максимальный размер файла лога до ротации (по умолчанию 10 МБ).

Параметр `LOG_BACKUP_COUNT` устанавливает количество сохраняемых архивных файлов логов (по умолчанию 5).

### Переменные окружения для развертывания

**Docker конфигурация** использует переменные окружения для настройки контейнеризованного развертывания:

Переменная `RUN_MODE` определяет режим запуска приложения (`all`, `telegram`, `web`). Это позволяет запускать различные компоненты в отдельных контейнерах.

Параметр `WORKERS` настраивает количество worker процессов для веб-интерфейса (по умолчанию 4). Увеличение количества workers улучшает производительность под нагрузкой.

Переменная `PORT` определяет порт для веб-интерфейса (по умолчанию 5000). Система поддерживает настройку порта для интеграции с reverse proxy и load balancer.

**Переменные безопасности** обеспечивают защиту в продакшн средах:

Параметр `SECURE_COOKIES` включает secure флаг для cookies в HTTPS средах.

Переменная `CSRF_PROTECTION` активирует защиту от CSRF атак для веб-интерфейса.

Параметр `CORS_ORIGINS` определяет разрешенные домены для CORS запросов.

### Валидация и значения по умолчанию

**Система валидации конфигурации** проверяет корректность параметров при запуске приложения:

Функция `validate_config()` проверяет наличие обязательных переменных, корректность форматов значений и совместимость параметров между собой.

Система автоматически создает отсутствующие директории, проверяет доступность внешних сервисов и валидирует API ключи.

**Значения по умолчанию** обеспечивают работоспособность системы в минимальной конфигурации:

Все необязательные параметры имеют разумные значения по умолчанию, оптимизированные для типичных случаев использования.

Система предоставляет предупреждения при использовании значений по умолчанию для критически важных параметров безопасности.

**Документация конфигурации** включает описания всех параметров, их влияние на производительность и безопасность, а также рекомендации по настройке для различных сред развертывания.


## Безопасность и ограничения

Система реализует многоуровневую архитектуру безопасности, включающую защиту от различных типов атак, валидацию входных данных, безопасное управление секретами и комплексный мониторинг подозрительных активностей. Архитектура безопасности построена на принципах defense in depth и zero trust.

### Защита от инъекций и атак

**Система защиты от SQL инъекций** реализована на нескольких уровнях архитектуры данных:

Использование SQLAlchemy ORM с параметризованными запросами исключает возможность прямых SQL инъекций через пользовательский ввод. Все запросы к базе данных используют bound parameters, которые автоматически экранируются ORM.

Валидация входных данных через `sanitize_input()` проверяет пользовательские сообщения на наличие SQL ключевых слов и специальных символов. Система обнаруживает попытки инъекций через паттерны `SELECT`, `DROP`, `INSERT`, `UPDATE`, `DELETE` в различных регистрах и комбинациях.

Ограничения прав доступа к базе данных обеспечивают минимальные необходимые привилегии для приложения. Пользователь базы данных имеет только права на чтение и запись в определенные таблицы без административных привилегий.

**Защита от XSS атак** включает санитизацию всех данных, отображаемых в веб-интерфейсе:

Автоматическое экранирование HTML в Jinja2 шаблонах предотвращает выполнение вредоносного JavaScript кода. Все пользовательские данные проходят через HTML escape функции перед отображением.

Content Security Policy (CSP) заголовки ограничивают источники выполняемого JavaScript и загружаемых ресурсов. Система запрещает inline скрипты и разрешает загрузку ресурсов только с доверенных доменов.

Валидация входных данных удаляет HTML теги и JavaScript события из пользовательских сообщений. Система обнаруживает и блокирует попытки внедрения `<script>`, `<iframe>`, `<object>` тегов и event handlers.

**Защита от Command Injection** предотвращает выполнение системных команд через пользовательский ввод:

Система не использует прямые вызовы системных команд с пользовательскими данными. Все операции с файлами выполняются через безопасные Python API.

Валидация имен файлов через `secure_filename()` удаляет специальные символы и пути, которые могут использоваться для directory traversal атак.

Ограничения на типы и размеры загружаемых файлов предотвращают загрузку вредоносных исполняемых файлов или файлов чрезмерного размера.

### Управление секретами и аутентификация

**Безопасное хранение секретов** реализовано через переменные окружения и внешние системы управления секретами:

API ключи, пароли баз данных и JWT секреты никогда не хранятся в коде приложения. Все секретные данные передаются через переменные окружения или монтируемые файлы в контейнеризованных средах.

Функция `sanitize_environment_variables()` сканирует ответы языковой модели на наличие потенциальных секретов и заменяет их безопасными заглушками. Система обнаруживает паттерны API ключей, токенов и паролей.

Ротация секретов поддерживается через graceful restart механизмы, позволяющие обновлять ключи без прерывания обслуживания пользователей.

**JWT аутентификация** обеспечивает безопасный доступ к веб-интерфейсу:

Токены подписываются криптографически стойким секретным ключом и включают expiration time для ограничения времени жизни. Система автоматически отклоняет истекшие или поврежденные токены.

Refresh token механизм позволяет продлевать сессии без повторной аутентификации, но с ограниченным временем жизни для снижения рисков компрометации.

Ролевая модель доступа (admin, operator, viewer) ограничивает функциональность в зависимости от прав пользователя. Система проверяет роли на каждом защищенном endpoint.

**Хеширование паролей** использует bcrypt с настраиваемым cost factor:

Система использует криптографически стойкий алгоритм bcrypt для хеширования паролей пользователей. Cost factor настроен для обеспечения баланса между безопасностью и производительностью.

Salt генерируется автоматически для каждого пароля, предотвращая rainbow table атаки. Система не хранит пароли в открытом виде ни в базе данных, ни в логах.

### Rate Limiting и защита от DoS

**Многоуровневая система rate limiting** защищает различные компоненты от злоупотреблений:

Telegram rate limiting ограничивает количество сообщений от каждого пользователя в настраиваемом временном окне. Система применяет прогрессивные блокировки для повторных нарушителей.

Web API rate limiting защищает административный интерфейс от автоматизированных атак. Система отслеживает запросы по IP адресу и применяет временные блокировки при превышении лимитов.

OpenAI API rate limiting предотвращает исчерпание квот и контролирует расходы на API вызовы. Система включает circuit breaker pattern для защиты от каскадных сбоев.

**Распределенное отслеживание лимитов** через Redis обеспечивает консистентность в кластерных развертываниях:

Система использует Redis для хранения счетчиков запросов и временных блокировок. Это позволяет масштабировать приложение горизонтально без потери эффективности rate limiting.

Sliding window алгоритм обеспечивает более точное отслеживание частоты запросов по сравнению с fixed window подходами.

**Защита от DDoS атак** включает несколько уровней защиты:

Application level защита через rate limiting и валидацию запросов предотвращает перегрузку приложения вредоносным трафиком.

Интеграция с reverse proxy (nginx, Cloudflare) обеспечивает network level защиту от volumetric атак.

Graceful degradation позволяет системе продолжать обслуживание критических функций даже под нагрузкой.

### Мониторинг безопасности и логирование

**Комплексная система логирования безопасности** отслеживает все потенциально опасные активности:

Таблица `suspicious_inputs` автоматически записывает все попытки инъекций, подозрительные паттерны ввода и превышения rate limits. Система включает IP адреса, временные метки и детали обнаруженных угроз.

Логирование аутентификации отслеживает все попытки входа в систему, включая неуспешные попытки, изменения паролей и создание новых пользователей.

Audit trail для административных действий записывает все изменения конфигурации, управление пользователями и операции с базой знаний.

**Автоматическое обнаружение аномалий** анализирует паттерны использования для выявления подозрительных активностей:

Система отслеживает частоту запросов от пользователей и автоматически помечает аномальное поведение. Резкое увеличение активности может указывать на автоматизированные атаки.

Анализ содержимого сообщений выявляет попытки social engineering, phishing и других форм манипуляций.

Мониторинг ошибок API помогает обнаруживать попытки эксплуатации уязвимостей или reconnaissance активности.

**Интеграция с SIEM системами** поддерживается через структурированное JSON логирование:

Система генерирует логи в формате, совместимом с популярными SIEM платформами (Splunk, ELK Stack, QRadar).

Автоматические алерты настроены для критических событий безопасности: множественные неуспешные попытки аутентификации, обнаружение инъекций, превышение rate limits.

### Ограничения и известные уязвимости

**Ограничения архитектуры** включают несколько аспектов, которые требуют внимания при развертывании:

Система использует глобальные словари Python для отслеживания активных сессий операторов. В кластерных развертываниях это может привести к несинхронизированному состоянию между экземплярами приложения. Рекомендуется использовать Redis или другое внешнее хранилище для состояния сессий.

OpenAI API dependency создает единую точку отказа для основной функциональности системы. При недоступности OpenAI API система может предоставлять только базовые ответы или эскалировать все запросы к операторам.

Отсутствие end-to-end шифрования для сообщений пользователей означает, что администраторы системы имеют доступ к полному содержимому диалогов. Это может создавать проблемы конфиденциальности в некоторых юрисдикциях.

**Потенциальные векторы атак** требуют дополнительного внимания:

Prompt injection атаки через специально сформированные пользовательские сообщения могут потенциально манипулировать поведением языковой модели. Система включает базовую защиту, но сложные атаки могут обходить существующие фильтры.

File upload уязвимости могут возникать при обработке специально сформированных документов. Система валидирует типы файлов, но не выполняет глубокий анализ содержимого на предмет вредоносного кода.

Session fixation атаки теоретически возможны при компрометации JWT токенов. Система использует короткое время жизни токенов для минимизации рисков.

**Рекомендации по усилению безопасности** включают дополнительные меры защиты:

Внедрение Web Application Firewall (WAF) для дополнительной защиты от известных векторов атак и автоматической блокировки вредоносного трафика.

Регулярные security audits и penetration testing для выявления новых уязвимостей и проверки эффективности существующих защитных механизмов.

Внедрение Content Disarm and Reconstruction (CDR) для безопасной обработки загружаемых документов и удаления потенциально вредоносного содержимого.

Использование Hardware Security Modules (HSM) или cloud-based key management services для защиты критически важных секретов в enterprise развертываниях.

### Соответствие стандартам безопасности

**GDPR и конфиденциальность данных** требуют дополнительных мер для соответствия европейским стандартам:

Система должна поддерживать право на забвение (right to be forgotten) через механизмы удаления всех данных пользователя по запросу.

Data minimization принципы требуют ограничения сбора и хранения только необходимых данных для функционирования системы.

Consent management должен быть реализован для получения явного согласия пользователей на обработку их персональных данных.

**SOC 2 Type II соответствие** может потребоваться для enterprise клиентов:

Система должна документировать все процедуры безопасности, включая управление доступом, мониторинг и incident response.

Regular security assessments и third-party audits необходимы для подтверждения соответствия стандартам.

**ISO 27001 требования** включают формализацию процессов управления информационной безопасностью:

Information Security Management System (ISMS) должна быть документирована и регулярно пересматриваться.

Risk assessment процедуры должны регулярно выполняться для выявления новых угроз и уязвимостей.

Business continuity planning должен включать процедуры восстановления после security incidents и data breaches.


## API Reference

Система предоставляет RESTful API для интеграции с внешними системами и управления функциональностью через программные интерфейсы. API построен на принципах REST архитектуры с JSON форматом данных и стандартными HTTP методами.

### Аутентификация API

**Endpoint: POST /api/auth/login**

Аутентифицирует пользователя и возвращает JWT токен для доступа к защищенным endpoints.

```json
Request:
{
  "username": "admin",
  "password": "secure_password"
}

Response (200):
{
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
  "user": {
    "id": 1,
    "username": "admin",
    "role": "admin"
  }
}

Response (401):
{
  "error": "Invalid credentials"
}
```

**Endpoint: GET /api/auth/check**

Валидирует активный JWT токен и возвращает информацию о пользователе.

```json
Headers:
Authorization: Bearer <jwt_token>

Response (200):
{
  "user": {
    "id": 1,
    "username": "admin",
    "role": "admin"
  }
}

Response (401):
{
  "error": "Token expired or invalid"
}
```

**Endpoint: POST /api/auth/users**

Создает нового пользователя системы. Доступно только администраторам.

```json
Request:
{
  "username": "operator1",
  "password": "secure_password",
  "role": "operator"
}

Response (201):
{
  "message": "User created successfully",
  "user": {
    "id": 2,
    "username": "operator1",
    "role": "operator"
  }
}
```

### Управление активными диалогами

**Endpoint: GET /api/ops/active-chats**

Возвращает список активных диалогов, ожидающих ответа оператора.

```json
Response (200):
{
  "chats": [
    {
      "user_id": 123456789,
      "last_message": "Помогите с заказом",
      "timestamp": "2025-08-07T10:30:00Z",
      "category": "Заказ",
      "status": "pending"
    }
  ]
}
```

**Endpoint: GET /api/ops/my-chats**

Возвращает список активных диалогов, назначенных текущему оператору.

```json
Response (200):
{
  "chats": [
    {
      "user_id": 123456789,
      "operator_id": 1,
      "start_time": "2025-08-07T10:35:00Z",
      "last_activity": "2025-08-07T10:40:00Z",
      "status": "active"
    }
  ]
}
```

**Endpoint: POST /api/ops/chat/{user_id}/accept**

Принимает ожидающий диалог и назначает его текущему оператору.

```json
Response (200):
{
  "message": "Chat accepted successfully",
  "session_id": 42
}

Response (409):
{
  "error": "Chat already accepted by another operator"
}
```

**Endpoint: GET /api/ops/chat/{user_id}/messages**

Возвращает историю сообщений для конкретного диалога.

```json
Response (200):
{
  "messages": [
    {
      "id": 1,
      "user_id": 123456789,
      "message_text": "Помогите с заказом",
      "bot_response": null,
      "timestamp": "2025-08-07T10:30:00Z",
      "sender": "user"
    },
    {
      "id": 2,
      "user_id": 123456789,
      "message_text": "Оператор: Здравствуйте! Чем могу помочь?",
      "bot_response": null,
      "timestamp": "2025-08-07T10:35:00Z",
      "sender": "operator"
    }
  ]
}
```

**Endpoint: POST /api/ops/chat/{user_id}/message**

Отправляет сообщение от оператора пользователю.

```json
Request:
{
  "message": "Ваш заказ находится в обработке"
}

Response (200):
{
  "message": "Message sent successfully"
}

Response (403):
{
  "error": "Not authorized for this chat"
}
```

**Endpoint: POST /api/ops/chat/{user_id}/end**

Завершает активную сессию с пользователем.

```json
Response (200):
{
  "message": "Session ended successfully"
}
```

### Управление базой знаний

**Endpoint: POST /api/ops/knowledge-base/upload**

Загружает документ в базу знаний для индексации.

```json
Request (multipart/form-data):
file: <document_file>
description: "Инструкция по оформлению заказов"

Response (200):
{
  "message": "Document uploaded and indexed successfully",
  "document": {
    "id": 15,
    "filename": "order_instructions.pdf",
    "description": "Инструкция по оформлению заказов",
    "upload_time": "2025-08-07T11:00:00Z",
    "uploaded_by": "admin"
  }
}

Response (400):
{
  "error": "Invalid file type or size"
}
```

**Endpoint: GET /api/ops/knowledge-base/documents**

Возвращает список загруженных документов в базе знаний.

```json
Response (200):
{
  "documents": [
    {
      "id": 15,
      "filename": "order_instructions.pdf",
      "description": "Инструкция по оформлению заказов",
      "upload_time": "2025-08-07T11:00:00Z",
      "uploaded_by": "admin",
      "size": 1024000
    }
  ]
}
```

**Endpoint: DELETE /api/ops/knowledge-base/documents/{document_id}**

Удаляет документ из базы знаний.

```json
Response (200):
{
  "message": "Document deleted successfully"
}

Response (404):
{
  "error": "Document not found"
}
```

### Статистика и аналитика

**Endpoint: GET /api/stats/overview**

Возвращает общую статистику использования системы.

```json
Response (200):
{
  "total_messages": 1250,
  "total_sessions": 89,
  "average_confidence": 0.82,
  "escalation_rate": 0.15,
  "average_rating": 4.2,
  "active_operators": 3,
  "response_time_avg": 2.5
}
```

**Endpoint: GET /api/stats/messages**

Возвращает статистику сообщений с фильтрацией по времени.

```json
Query Parameters:
- start_date: ISO date string (optional)
- end_date: ISO date string (optional)
- user_id: integer (optional)

Response (200):
{
  "messages": [
    {
      "date": "2025-08-07",
      "count": 45,
      "avg_confidence": 0.78,
      "escalations": 7
    }
  ],
  "total_count": 45,
  "period_start": "2025-08-07T00:00:00Z",
  "period_end": "2025-08-07T23:59:59Z"
}
```

**Endpoint: GET /api/stats/operators**

Возвращает статистику производительности операторов.

```json
Response (200):
{
  "operators": [
    {
      "operator_id": 1,
      "username": "operator1",
      "sessions_handled": 25,
      "avg_session_duration": 15.5,
      "avg_rating": 4.3,
      "response_time_avg": 2.1
    }
  ]
}
```

**Endpoint: GET /api/stats/ratings**

Возвращает статистику оценок пользователей.

```json
Response (200):
{
  "ratings_distribution": {
    "1": 2,
    "2": 3,
    "3": 8,
    "4": 25,
    "5": 35
  },
  "average_rating": 4.2,
  "total_ratings": 73,
  "feedback_count": 15
}
```

### История и поиск

**Endpoint: GET /api/history/messages**

Возвращает историю сообщений с поддержкой поиска и фильтрации.

```json
Query Parameters:
- q: search query (optional)
- user_id: integer (optional)
- start_date: ISO date string (optional)
- end_date: ISO date string (optional)
- limit: integer (default: 50)
- offset: integer (default: 0)

Response (200):
{
  "messages": [
    {
      "id": 1,
      "user_id": 123456789,
      "timestamp": "2025-08-07T10:30:00Z",
      "message_text": "Как оформить заказ?",
      "bot_response": "Для оформления заказа...",
      "confidence_score": 0.85,
      "language": "ru"
    }
  ],
  "total_count": 1250,
  "has_more": true
}
```

**Endpoint: GET /api/history/sessions**

Возвращает историю сессий с операторами.

```json
Response (200):
{
  "sessions": [
    {
      "id": 42,
      "user_id": 123456789,
      "operator_id": 1,
      "start_time": "2025-08-07T10:35:00Z",
      "end_time": "2025-08-07T10:50:00Z",
      "rating": 5,
      "feedback": "Очень помогли!"
    }
  ]
}
```

### Webhook интеграции

**Endpoint: POST /api/webhooks/telegram**

Обрабатывает входящие webhook от Telegram Bot API.

```json
Request:
{
  "update_id": 123456,
  "message": {
    "message_id": 789,
    "from": {
      "id": 123456789,
      "first_name": "John",
      "username": "john_doe"
    },
    "chat": {
      "id": 123456789,
      "type": "private"
    },
    "date": 1691400000,
    "text": "Привет!"
  }
}

Response (200):
{
  "status": "ok"
}
```

### Коды ошибок и обработка

Система использует стандартные HTTP коды состояния для индикации результатов API запросов:

**200 OK** - Запрос выполнен успешно  
**201 Created** - Ресурс создан успешно  
**400 Bad Request** - Некорректные параметры запроса  
**401 Unauthorized** - Требуется аутентификация  
**403 Forbidden** - Недостаточно прав доступа  
**404 Not Found** - Ресурс не найден  
**409 Conflict** - Конфликт состояния ресурса  
**429 Too Many Requests** - Превышен rate limit  
**500 Internal Server Error** - Внутренняя ошибка сервера  

**Формат ошибок:**

```json
{
  "error": "Описание ошибки",
  "code": "ERROR_CODE",
  "details": {
    "field": "Дополнительная информация"
  }
}
```

### Rate Limiting заголовки

API включает заголовки для информирования клиентов о текущих лимитах:

```
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1691403600
```

### Версионирование API

Текущая версия API: v1. Версия указывается в URL пути: `/api/v1/...`

Система поддерживает обратную совместимость в рамках мажорной версии и предоставляет уведомления о deprecated endpoints через специальные заголовки.

---

## Заключение

Данная техническая документация представляет комплексный анализ архитектуры и функциональности телеграм-бота поддержки клиентов с интегрированным искусственным интеллектом. Система демонстрирует современный подход к автоматизации клиентской поддержки, объединяя передовые технологии RAG, многоуровневую систему эскалации и комплексную аналитику.

Архитектура системы построена на принципах модульности, масштабируемости и безопасности, что обеспечивает гибкость развертывания от простых SQLite установок до enterprise-grade PostgreSQL кластеров. Использование контейнеризации через Docker и поддержка различных режимов запуска позволяет адаптировать систему под различные требования инфраструктуры.

Система включает комплексные механизмы безопасности, включая защиту от инъекций, rate limiting, валидацию входных данных и мониторинг подозрительных активностей. Многоуровневая архитектура безопасности обеспечивает защиту как от автоматизированных атак, так и от человеческих ошибок.

Интеграция с современными AI технологиями через OpenAI API и ChromaDB обеспечивает высокое качество автоматических ответов при сохранении возможности эскалации к операторам-людям для сложных случаев. Система follow-up вопросов и обратной связи создает непрерывный цикл улучшения качества обслуживания.

Веб-интерфейс предоставляет операторам и администраторам мощные инструменты для управления диалогами, анализа статистики и обновления базы знаний. RESTful API обеспечивает возможности интеграции с внешними системами и автоматизации административных задач.

Система готова к продакшн развертыванию и может служить основой для корпоративных решений автоматизации клиентской поддержки с требованиями высокой доступности, безопасности и масштабируемости.

